package com.isecpartners.samplesync.model;

import java.util.List;
import java.util.LinkedList;
import android.util.Log;

/*
 * Synching algorithm.  Merging happens on three sets of
 * contacts, the "local" contacts fetched from the phone that
 * were generated by other contact providers and the user,
 * the "remote" contacts fetched from our remote storage of
 * contacts and the "last" contacts, which we store on the phone
 * after each synch and represent the state of the contacts 
 * after the last synch point.
 *
 * To synch we first correlate the contacts from all three sources
 * together (whenever possible).  Then for each contact, we see
 * if there are changes between the last set and the local set
 * or the last set and the remote set.  If there are changes from
 * two sources, we resolve the conflict (simplistically by choosing
 * one set of changes over the other).  Then we apply these changes
 * to bring all three contacts into agreement.  This is done by
 * first updating the "last" contact, and then applying any difference
 * between the "last" contact and the local or remote (whichever
 * was not the source of the changes) to that contact.  When
 * applying these changes, the updates to the databases are made
 * (local and last are stored in the contacts manager) and the
 * in-memory copy of the remote contacts is updated.  After 
 * all contacts are synched, the remote contacts are serialized into
 * a blob and sent to the remote storage.
 */
public class Synch {
    final static String TAG = "model.Synch";

    ContactSet mLast, mLocal, mRemote;
    boolean mPreferLocal;

    /* return the first d from ds that has mime type mime, or null. */
    static CData firstDataMime(Contact c, String mime) {
        for(CData d : c.data) {
            if(d.mime.compareTo(mime) == 0)
                return d;
        }
        return null;
    }

    /* return a score for how well x matches c */
    static int match(Contact x, Contact c) {
        if(x.data.isEmpty() && c.data.isEmpty())
            return 1;

        int sum = 0;
        for(CData xd : x.data) {
            for(CData cd : c.data) {
                if(xd.equals(cd))
                    sum += xd.getMatchScore();
            }
        }
        return sum;
    }

    /*
     * Return the most specific match to x from unmatched entries in cs.
     * Caller should mark all cs as unmatched before starting.
     */
    static Contact bestMatch(Contact x, List<Contact> cs) {
        int bestScore = 0;
        Contact bestMatch = null;

        for(Contact c : cs) {
            if(!c.matched) {
                int score = match(x, c);
                if(score > bestScore) {
                    bestScore = score;
                    bestMatch = c;
                }
            }
        }
        if(bestMatch != null)
            bestMatch.matched = true;
        return bestMatch;
    }

    /*
     * Merge contacts from different sources onto a single list,
     * keeping track of whence they came.
     *
     * When finished, all contacts have a "master" field which links
     * to an element on the returned list (which might be the contact
     * itself).  Each element on the returned list has fields
     * "remote", "local" and "last" which point to any merged entries
     * from the local, remote or last lists.
     */
    static List<Contact> merge(List<Contact> last, List<Contact> local, List<Contact> remote) {
        LinkedList<Contact> all = new LinkedList<Contact>();

        // XXX for performance maybe we should sort all three
        // lists based on some metric before merging, then the
        // rest of merging can be linear.
        // If last and remote are kept sorted then only local needs sorting.

        // put all "last" entries onto the list
        for(Contact c : last) {
            c.last = c;
            c.master = c;
            all.add(c);
        }

        // merge all "local" entries onto the list
        Contact m;
        for(Contact c : all) 
            c.matched = false;
        for(Contact c : local) {
            if((m = bestMatch(c, all)) != null) {
                m.local = c;
                c.master = m;
            } else { // not found
                c.local = c; 
                c.master = m;
                all.add(c);
            }
        }

        // merge all "remote" entries onto the list
        for(Contact c : all) 
            c.matched = false;
        for(Contact c : remote) {
            if((m = bestMatch(c, all)) != null) {
                m.remote = c;
                c.master = m;
            } else { // not found
                c.remote = c; 
                c.master = c;
                all.add(c);
            }
        }
        return all;
    }

    /* 
     * The changes between two contacts.
     * It has a flag if this contact is added, if it is deleted,
     * and a list of data items that were added or deleted.
     */
    public static class Changes {
        public boolean delContact;
        public List<CData> addData, delData;

        public Changes(boolean del, List<CData> a, List<CData> d) {
            delContact = del;
            addData = a;
            delData = d;
        }
    };

    /* copy the list */
    static <D> List<D> copy(List<D> ds) {
        if(ds == null)
            return null;
        return new LinkedList<D>(ds);
    }

    /* return all elements in ds that arent in ds2 (ie: ds - ds2)*/
    static <D> List<D> diff(List<D> ds, List<D> ds2) {
        LinkedList<D> r = new LinkedList<D>();
        for(D d : ds) {
            if(!ds2.contains(d))
                r.add(d);
        }
        return r.isEmpty() ? null : r;
    }

    /*
     * Return the delta to change c2 into c (ie: c - c2).
     * Returns null if they are the same (ie: c - c2 = 0).
     */
    static Changes changes(Contact c, Contact c2) {
        if(c == null && c2 == null)
            return null;
        if(c == null)
            return new Changes(true, null, copy(c2.data)); // delete, -c2
        if(c2 == null)
            return new Changes(false, copy(c.data), null); // add, +c

        List<CData> adds = Synch.<CData>diff(c.data, c2.data); // +(c - c2)
        List<CData> dels = Synch.<CData>diff(c2.data, c.data); // -(c2 - c)
        if(adds == null && dels == null)
            return null;
        return new Changes(false, adds, dels); // alter data
    }

    /* sync changes from local sources */
    boolean syncLocal(Contact c) {
        Changes d = changes(c.local, c.last); // d = local - last
        if(d == null)
            return false;

        /* bring last up to date */
        c.last = mLast.push(c.last, d); // last += d

        /* then bring remote up to date */
        Changes d2 = changes(c.last, c.remote); // d2 = last - remote
        if(d2 != null)
            c.remote = mRemote.push(c.remote, d2); // remote += d2
        return true;
    }

    /* sync changes from remote sources */
    boolean syncRemote(Contact c) {
        Changes d = changes(c.remote, c.last); // d = remote - last
        if(d == null)
            return false;

        /* bring last up to date */
        c.last = mLast.push(c.last, d); // last += d

        /* then bring local up to date */
        Changes d2 = changes(c.last, c.local); // d2 = last - local
        if(d2 != null)
            c.local = mLocal.push(c.local, d2); // local += d2
        return true;
    }

    /*
     * Sync data.
     * Use "last" as a comparison points for "local" and "remote" to
     * find differences, and propagate differences to the local
     * contacts database and the remote database while bringing "last"
     * up to date.
     * If "preferLocal" is true, prefer local edits over remote edits,
     * otherwise prefer remote edits over local edits.
     * Return true if any changes were encountered.
     */
    public boolean sync() {
        List<Contact> all = merge(mLast.contacts, mLocal.contacts, mRemote.contacts);

        { // XXX extra logging for now, consider removing later
            for(Contact c : all) {
                Log.v(TAG, "all: " + c);
                Log.v(TAG, "   last: " + c.last);
                Log.v(TAG, "   loca: " + c.local);
                Log.v(TAG, "   remo: " + c.local);
            }
        }

        boolean b, updated = false;
        for(Contact c : all) {
            if(mPreferLocal)
                b = syncLocal(c) || syncRemote(c);
            else
                b = syncRemote(c) || syncLocal(c);
            if(b)
                updated = true;
        }
        return updated;
    }

    public Synch(ContactSet last, ContactSet local, ContactSet remote, boolean preferLocal) {
        mLast = last;
        mLocal = local;
        mRemote = remote;
        mPreferLocal = preferLocal;
    }
}

