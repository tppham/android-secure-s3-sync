package com.isecpartners.samplesync.model;

import java.util.List;
import java.util.LinkedList;
import java.util.Set;
import java.util.TreeSet;
import android.util.Log;

/*
 * Synching algorithm.  Merging happens on three sets of
 * contacts, the "local" contacts fetched from the phone that
 * were generated by other contact providers and the user,
 * the "remote" contacts fetched from our remote storage of
 * contacts and the "last" contacts, which we store on the phone
 * after each synch and represent the state of the contacts 
 * after the last synch point.
 *
 * To synch we first correlate the contacts from all three sources
 * together (whenever possible).  Then for each contact, we see
 * if there are changes between the last set and the local set
 * or the last set and the remote set.  If there are changes from
 * two sources, we resolve the conflict (simplistically by choosing
 * one set of changes over the other).  Then we apply these changes
 * to bring all three contacts into agreement.  This is done by
 * first updating the "last" contact, and then applying any difference
 * between the "last" contact and the local or remote (whichever
 * was not the source of the changes) to that contact.  When
 * applying these changes, the updates to the databases are made
 * (local and last are stored in the contacts manager) and the
 * in-memory copy of the remote contacts is updated.  After 
 * all contacts are synched, the remote contacts are serialized into
 * a blob and sent to the remote storage.
 */
public class Synch {
    final static String TAG = "model.Synch";

    ContactSet mLast, mLocal, mRemote;
    boolean mPreferLocal;

    /* return a score for how well x matches m */
    static int match(Contact x, Merge m) {
        Contact c = m.master;
        int sum = 0;

        // if both are empty they might as well be considered the same
        if(x.data.isEmpty() && c.data.isEmpty()) 
            sum += 1;

        // ID matches are our best bet, but lets not give them
        // more weight than many data matches.
        if(x.remid != x.UNKNOWN_ID && x.remid == c.remid)
            sum += 50;
        if(x.locid != x.UNKNOWN_ID && x.locid == c.locid)
            sum += 50;

        // give a little weight to each datum match
        for(CData xd : x.data) {
            for(CData cd : c.data) {
                if(xd.equals(cd))
                    sum += xd.getMatchScore();
            }
        }
        return sum;
    }

    // a merged contact
    static class Merge {
        public Contact master, last, local, remote;
        public boolean matched;
        public Merge(Contact x) { master = x; }
    }

    /*
     * Return the most specific match to x from unmatched entries in ms.
     * If no matches are found, add x to ms and return it.
     * Caller should mark all cs as unmatched before starting.
     */
    static Merge bestMatch(Contact x, List<Merge> ms) {
        int bestScore = 0;
        Merge bestMatch = null;

        for(Merge m : ms) {
            if(!m.matched) {
                int score = match(x, m);
                if(score > bestScore) {
                    bestScore = score;
                    bestMatch = m;
                }
            }
        }

        if(bestMatch == null) {
            bestMatch = new Merge(x);
            ms.add(bestMatch);
        }
        bestMatch.matched = true;
        return bestMatch;
    }


    /*
     * Merge contacts from different sources onto a single list,
     * keeping track of whence they came.
     *
     * When finished, all contacts have a "master" field which links
     * to an element on the returned list (which might be the contact
     * itself).  Each element on the returned list has fields
     * "remote", "local" and "last" which point to any merged entries
     * from the local, remote or last lists.
     *
     * This process is inefficient, but hopefully the problem size is
     * small.  If this turns out to be a bottleneck, we can do a fast
     * merge based on locid/remid (using a precomputed map) and then
     * use the slower method for any remaining items.  This will be
     * very fast in the common case.
     */
    static List<Merge> merge(List<Contact> last, List<Contact> local, List<Contact> remote) {
        List<Merge> all = new LinkedList<Merge>();

        // put all "last" entries onto the list
        for(Merge m : all)  // note: empty list, nop
            m.matched = false;
        for(Contact c : last) {
            Merge m = bestMatch(c, all); // always returns c.
            m.last = c;
        }

        // merge all "local" entries onto the list
        for(Merge m : all) 
            m.matched = false;
        for(Contact c : local) {
            Merge m = bestMatch(c, all);
            m.local = c;
        }

        // merge all "remote" entries onto the list
        for(Merge m : all) 
            m.matched = false;
        for(Contact c : remote) {
            Merge m = bestMatch(c, all);
            m.remote = c;
        }
        return all;
    }

    /* 
     * The changes between two contacts.
     * It has a flag if this contact is added, if it is deleted,
     * and a list of data items that were added or deleted.
     */
    public static class Changes {
        public boolean delContact;
        public List<CData> addData, delData;

        public Changes(boolean del, List<CData> a, List<CData> d) {
            delContact = del;
            addData = a;
            delData = d;
        }
    };

    /* copy the list */
    static <D> List<D> copy(List<D> ds) {
        if(ds == null)
            return null;
        return new LinkedList<D>(ds);
    }

    /* return all elements in ds that arent in ds2 (ie: ds - ds2)*/
    static <D> List<D> diff(List<D> ds, List<D> ds2) {
        LinkedList<D> r = new LinkedList<D>();
        for(D d : ds) {
            if(!ds2.contains(d))
                r.add(d);
        }
        return r.isEmpty() ? null : r;
    }

    /*
     * Return the delta to change c2 into c (ie: c - c2).
     * Returns null if they are the same (ie: c - c2 = 0).
     */
    static Changes changes(Contact c, Contact c2) {
        if(c == null && c2 == null)
            return null;
        if(c == null)
            return new Changes(true, null, copy(c2.data)); // delete, -c2
        if(c2 == null)
            return new Changes(false, copy(c.data), null); // add, +c

        List<CData> adds = Synch.<CData>diff(c.data, c2.data); // +(c - c2)
        List<CData> dels = Synch.<CData>diff(c2.data, c.data); // -(c2 - c)
        if(adds == null && dels == null)
            return null;
        return new Changes(false, adds, dels); // alter data
    }

    /* sync changes from local sources */
    boolean syncLocal(Merge m) {
        Changes d = changes(m.local, m.last); // d = local - last
        if(d == null)
            return false;

        /* bring last up to date */
        m.last = mLast.push(m.last, d); // last += d

        /* then bring remote up to date */
        Changes d2 = changes(m.last, m.remote); // d2 = last - remote
        if(d2 != null)
            m.remote = mRemote.push(m.remote, d2); // remote += d2
        return true;
    }

    /* sync changes from remote sources */
    boolean syncRemote(Merge m) {
        Changes d = changes(m.remote, m.last); // d = remote - last
        if(d == null)
            return false;

        /* bring last up to date */
        m.last = mLast.push(m.last, d); // last += d

        /* then bring local up to date */
        Changes d2 = changes(m.last, m.local); // d2 = last - local
        if(d2 != null)
            m.local = mLocal.push(m.local, d2); // local += d2
        return true;
    }

    long allocID(Set<Long> alloced, long nextID) {
        while(true) {
            nextID ++;
            if(nextID == 0 || nextID == -1)
                nextID = 1;
            if(!alloced.contains(nextID))
                break;
        }
        alloced.add(nextID);
        return nextID;
    }

    /*
     * At this point all local data items should have proper
     * IDs, but remote IDs may not have been assigned yet.
     * Create new IDs for each remote contact that doesn't have one,
     * and make sure our "last" set has all the ID information.
     */
    void allocateIDs(List<Merge> ms) {
        // take note of which remote IDs are already used
        Set<Long> alloced = new TreeSet<Long>();
        long nextID = 0;
        for(Merge m : ms) {
            if(m.remote.remid != m.remote.UNKNOWN_ID)
                alloced.add(m.remote.remid);
        }

        for(Merge m : ms) {
            // sanity - locals dont track remotes and vice versa.
            if(!(m.local.remid == m.local.UNKNOWN_ID))
                Log.e(TAG, "assert m.local.remid == m.local.UNKNOWN_ID");
            if(!(m.remote.locid == m.remote.UNKNOWN_ID))
                Log.e(TAG, "assert m.remote.locid == m.remote.UNKNOWN_ID");

            // allocate IDs for any new remote entries
            if(m.remote.remid == m.remote.UNKNOWN_ID) {
                nextID = allocID(alloced, nextID);
                m.remote.remid = nextID;
            }

            // make sure "last" is up to date
            m.last.locid = m.local.locid;
            m.last.remid = m.remote.remid;
        }
    }

    // XXX extra logging for now, consider removing later
    void dump(List<Merge> all) {
        for(Merge m : all) {
            Log.v(TAG, "all: " + m.master);
            Log.v(TAG, "   last: " + m.last);
            Log.v(TAG, "   loca: " + m.local);
            Log.v(TAG, "   remo: " + m.remote);
        }
    }

    /*
     * Sync data.
     * Use "last" as a comparison points for "local" and "remote" to
     * find differences, and propagate differences to the local
     * contacts database and the remote database while bringing "last"
     * up to date.
     * If "preferLocal" is true, prefer local edits over remote edits,
     * otherwise prefer remote edits over local edits.
     * Return true if any changes were encountered.
     */
    public boolean sync() {
        List<Merge> all = merge(mLast.contacts, mLocal.contacts, mRemote.contacts);
        dump(all); // XXX

        boolean b, updated = false;
        List<Merge> done = new LinkedList<Merge>();
        for(Merge m : all) {
            if(mPreferLocal)
                b = syncLocal(m) || syncRemote(m);
            else
                b = syncRemote(m) || syncLocal(m);
            if(b)
                updated = true;

            if(m.last != null && m.local != null && m.remote != null)
                done.add(m);
        }

        // remember accounts in last set
        for(Merge m : done) {
            m.last.acctType = m.local.acctType;
            m.last.acctName = m.local.acctName;
        }

        // allocate IDs for any remotes that dont have IDs yet
        if(updated)
            allocateIDs(done);
        return updated;
    }

    public Synch(ContactSet last, ContactSet local, ContactSet remote, boolean preferLocal) {
        mLast = last;
        mLocal = local;
        mRemote = remote;
        mPreferLocal = preferLocal;
    }
}

